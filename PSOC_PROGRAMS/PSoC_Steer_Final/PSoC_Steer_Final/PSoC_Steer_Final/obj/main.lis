 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000                   .dbfunc e min _min fI
 0000           ;              b -> X-7
 0000           ;              a -> X-5
 0000           _min::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3802              add SP,2
 0004                   .dbline 70
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; #include "PSoCGPIOINT.h"
 0004           ; #include <string.h>
 0004           ; #include <stdlib.h>   
 0004           ; 
 0004           ; #pragma interrupt_handler PSoC_GPIO_ISR_C
 0004           ; 
 0004           ; #define POT_LEFT_BOUND 0x00FF
 0004           ; #define STEER_POT_CENTER 0x204
 0004           ; #define POT_RIGHT_BOUND 0x02EF
 0004           ; 
 0004           ; #define ENCODER_LEFT_BOUND -2300
 0004           ; #define ENCODER_RIGHT_BOUND 2300
 0004           ; 
 0004           ; #define BRAKE_MAX_POS 900
 0004           ; #define BRAKE_MIN_POS 100
 0004           ; 
 0004           ; #define STOP 0
 0004           ; 
 0004           ; #define BAUD_BYTE 0xAA
 0004           ; 
 0004           ; #define STEER_CTL 128
 0004           ; #define STEER_SPEED 80
 0004           ; #define LEFT 0
 0004           ; #define RIGHT 1
 0004           ; 
 0004           ; #define BRAKE_CTL 130
 0004           ; #define BRAKE_SPEED 120
 0004           ; #define RELEASE 0
 0004           ; #define APPLY 1
 0004           ; 
 0004           ; 
 0004           ; /******** PROTOTYPES ********/
 0004           ; 
 0004           ; // Get the ADC values of the appropriate sensor. Values will be cached until cacheValid is reset
 0004           ; unsigned int getBrakePosition(void);
 0004           ; unsigned int getSteerPotPosition(void);
 0004           ; 
 0004           ; // Tells the specified motor controller to run at the specfied speed. The
 0004           ; // controller will continue to run until it is explicity stopped. setControllerSpeed
 0004           ; // will cache the last parameters sent to each motor and only update the motor
 0004           ; // controller if the values have changed.
 0004           ; // Speed must be in the range [0, 127]
 0004           ; // dir is either a 0 or 1
 0004           ; void setControllerSpeed(BYTE addr, BYTE speed, BYTE dir);
 0004           ; 
 0004           ; // Set the current turn and brake setpoints. Both are clamped between the appropriate defines
 0004           ; void turn(int count);
 0004           ; void brake(int pVal);
 0004           ; 
 0004           ; // Stops all motors. This does not mean the brake will be applied.
 0004           ; void stop(void);
 0004           ; 
 0004           ; // Update the motor controller speeds based on the current setpoints
 0004           ; void updateBrakeCtl(void);
 0004           ; void updateTurnCtl(void);
 0004           ; 
 0004           ; // Realign the steer encoder so that 0 counts occurs when the pot is centered
 0004           ; void calibrateSteering(void);
 0004           ; 
 0004           ; int command_lookup(BYTE cmd);
 0004           ; 
 0004           ; int min(int, int);
 0004           ; int max(int, int);
 0004           ; int min(int a, int b) { return a < b ? a : b; }
 0004                   .dbline 70
 0004 52FC              mov A,[X-4]
 0006 13FA              sub A,[X-6]
 0008 52F9              mov A,[X-7]
 000A 3180              xor A,-128
 000C 62D000            mov REG[0xd0],>__r0
 000F 5300              mov [__rX],A
 0011 52FB              mov A,[X-5]
 0013 3180              xor A,-128
 0015 1A00              sbb A,[__rX]
 0017 D00B              jnc L3
 0019           X0:
 0019 52FC              mov A,[X-4]
 001B 5401              mov [X+1],A
 001D 52FB              mov A,[X-5]
 001F 5400              mov [X+0],A
 0021 8009              xjmp L4
 0023           L3:
 0023 52FA              mov A,[X-6]
 0025 5401              mov [X+1],A
 0027 52F9              mov A,[X-7]
 0029 5400              mov [X+0],A
 002B           L4:
 002B 62D000            mov REG[0xd0],>__r0
 002E 5201              mov A,[X+1]
 0030 5300              mov [__r1],A
 0032 5200              mov A,[X+0]
 0034 5300              mov [__r0],A
 0036                   .dbline -2
 0036           L1:
 0036 38FE              add SP,-2
 0038 20                pop X
 0039                   .dbline 0 ; func end
 0039 7F                ret
 003A                   .dbsym l b -7 I
 003A                   .dbsym l a -5 I
 003A                   .dbend
 003A                   .dbfunc e max _max fI
 003A           ;              b -> X-7
 003A           ;              a -> X-5
 003A           _max::
 003A                   .dbline -1
 003A 10                push X
 003B 4F                mov X,SP
 003C 3802              add SP,2
 003E                   .dbline 71
 003E           ; int max(int a, int b) { return a > b ? a : b; }
 003E                   .dbline 71
 003E 52FA              mov A,[X-6]
 0040 13FC              sub A,[X-4]
 0042 52FB              mov A,[X-5]
 0044 3180              xor A,-128
 0046 62D000            mov REG[0xd0],>__r0
 0049 5300              mov [__rX],A
 004B 52F9              mov A,[X-7]
 004D 3180              xor A,-128
 004F 1A00              sbb A,[__rX]
 0051 D00B              jnc L7
 0053           X1:
 0053 52FC              mov A,[X-4]
 0055 5401              mov [X+1],A
 0057 52FB              mov A,[X-5]
 0059 5400              mov [X+0],A
 005B 8009              xjmp L8
 005D           L7:
 005D 52FA              mov A,[X-6]
 005F 5401              mov [X+1],A
 0061 52F9              mov A,[X-7]
 0063 5400              mov [X+0],A
 0065           L8:
 0065 62D000            mov REG[0xd0],>__r0
 0068 5201              mov A,[X+1]
 006A 5300              mov [__r1],A
 006C 5200              mov A,[X+0]
 006E 5300              mov [__r0],A
 0070                   .dbline -2
 0070           L5:
 0070 38FE              add SP,-2
 0072 20                pop X
 0073                   .dbline 0 ; func end
 0073 7F                ret
 0074                   .dbsym l b -7 I
 0074                   .dbsym l a -5 I
 0074                   .dbend
 0074                   .dbfunc e main _main fV
 0074           ;           data -> X+2
 0074           ;      heartbeat -> X+0
 0074           _main::
 0074                   .dbline -1
 0074 10                push X
 0075 4F                mov X,SP
 0076 3804              add SP,4
 0078                   .dbline 94
 0078           ; 
 0078           ; 
 0078           ; /******** GLOBALS ********/
 0078           ; 
 0078           ; // Encoder state variables
 0078           ; BYTE prevPrt;
 0078           ; BYTE curPrt;
 0078           ; 
 0078           ; // Are currently cached analog reads valid, or should they be reaquired
 0078           ; BYTE cacheValid;
 0078           ; 
 0078           ; // The current count of the quadrature encoder connected to the steering column
 0078           ; int steerCount;
 0078           ; 
 0078           ; // The current target positions for both motor controllers
 0078           ; int brakeSetpoint;
 0078           ; int steerSetpoint;
 0078           ; 
 0078           ; 
 0078           ; /******** MAIN ********/
 0078           ; 
 0078           ; void main(void)
 0078           ; {
 0078                   .dbline 97
 0078           ;       char* data;
 0078           ;       
 0078           ;       unsigned int heartbeat = 0;
 0078 560100            mov [X+1],0
 007B 560000            mov [X+0],0
 007E                   .dbline 99
 007E           ;       
 007E           ;       M8C_EnableGInt ; 
 007E 7101                      or  F, 01h
 0080           
 0080                   .dbline 100
 0080           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);      // Enable GPIO Interrupts (see m8c.h)
 0080 43E020            or REG[0xe0],32
 0083                   .dbline 102
 0083           ;       
 0083           ;       UART_CmdReset();
 0083 10                push X
 0084 7C0000            xcall _UART_CmdReset
 0087                   .dbline 103
 0087           ;       UART_IntCntl(UART_ENABLE_RX_INT);
 0087 5001              mov A,1
 0089 7C0000            xcall _UART_IntCntl
 008C                   .dbline 104
 008C           ;       UART_Start(UART_PARITY_NONE);
 008C 5000              mov A,0
 008E 7C0000            xcall _UART_Start
 0091                   .dbline 106
 0091           ;       
 0091           ;       TX8_Start(TX8_PARITY_NONE);
 0091 5000              mov A,0
 0093 7C0000            xcall _TX8_Start
 0096                   .dbline 107
 0096           ;       TX8_EnableInt();
 0096 7C0000            xcall _TX8_EnableInt
 0099                   .dbline 108
 0099           ;       Actuator_Pot_Start(Actuator_Pot_HIGHPOWER);
 0099 5003              mov A,3
 009B 7C0000            xcall _Actuator_Pot_Start
 009E                   .dbline 109
 009E           ;       Steer_Pot_Start(Steer_Pot_HIGHPOWER);
 009E 5003              mov A,3
 00A0 7C0000            xcall _Steer_Pot_Start
 00A3                   .dbline 110
 00A3           ;       DUALADC_Start(DUALADC_HIGHPOWER);
 00A3 5003              mov A,3
 00A5 7C0000            xcall _DUALADC_Start
 00A8                   .dbline 112
 00A8           ;       
 00A8           ;       LCD_Start();
 00A8 7C0000            xcall _LCD_Start
 00AB                   .dbline 113
 00AB           ;       LCD_Position(0,0);
 00AB 5000              mov A,0
 00AD 5700              mov X,0
 00AF 7C0000            xcall _LCD_Position
 00B2                   .dbline 114
 00B2           ;       LCD_PrCString("Steering PSoC");
 00B2 5071              mov A,>L10
 00B4 08                push A
 00B5 5071              mov A,<L10
 00B7 5C                mov X,A
 00B8 18                pop A
 00B9 7C0000            xcall _LCD_PrCString
 00BC                   .dbline 116
 00BC           ;       
 00BC           ;       UART_CPutString("Steer Program Start\r\n");
 00BC 505B              mov A,>L11
 00BE 08                push A
 00BF 505B              mov A,<L11
 00C1 5C                mov X,A
 00C2 18                pop A
 00C3 7C0000            xcall _UART_CPutString
 00C6 20                pop X
 00C7 80D8              xjmp L13
 00C9           L12:
 00C9                   .dbline 122
 00C9           ;       //TX8_PutChar(baudChar);
 00C9           ;       //DAC8_1_Start(DAC8_1_HIGHPOWER);
 00C9           ;       //DAC8_1_WriteBlind(val);
 00C9           ;               
 00C9           ;       while (TRUE)
 00C9           ;       {
 00C9                   .dbline 123
 00C9           ;               cacheValid = FALSE;
 00C9 62D000            mov REG[0xd0],>_cacheValid
 00CC 550000            mov [_cacheValid],0
 00CF                   .dbline 125
 00CF           ;               
 00CF           ;               prevPrt = (PRT1DR & (OpEncA_MASK | OpEncB_MASK)); 
 00CF 5D04              mov A,REG[0x4]
 00D1 2130              and A,48
 00D3 62D000            mov REG[0xd0],>_prevPrt
 00D6 5300              mov [_prevPrt],A
 00D8                   .dbline 127
 00D8           ;               
 00D8           ;               if(heartbeat % 500 == 0)
 00D8 62D000            mov REG[0xd0],>__r0
 00DB 5001              mov A,1
 00DD 08                push A
 00DE 50F4              mov A,-12
 00E0 08                push A
 00E1 5200              mov A,[X+0]
 00E3 08                push A
 00E4 5201              mov A,[X+1]
 00E6 08                push A
 00E7 7C0000            xcall __divmodu_16X16_16
 00EA 38FE              add SP,-2
 00EC 18                pop A
 00ED 5300              mov [__r1],A
 00EF 18                pop A
 00F0 3900              cmp A,0
 00F2 B018              jnz L15
 00F4 3C0000            cmp [__r1],0
 00F7 B013              jnz L15
 00F9           X3:
 00F9                   .dbline 129
 00F9           ;               {
 00F9           ;                       UART_PutCRLF();
 00F9                   .dbline 129
 00F9 10                push X
 00FA 7C0000            xcall _UART_PutCRLF
 00FD                   .dbline 130
 00FD           ;                       UART_CPutString("ping");
 00FD 5056              mov A,>L17
 00FF 08                push A
 0100 5056              mov A,<L17
 0102 5C                mov X,A
 0103 18                pop A
 0104 7C0000            xcall _UART_CPutString
 0107                   .dbline 131
 0107           ;                       UART_PutCRLF();
 0107 7C0000            xcall _UART_PutCRLF
 010A 20                pop X
 010B                   .dbline 132
 010B           ;               }
 010B           L15:
 010B                   .dbline 133
 010B           ;               heartbeat++;
 010B 7701              inc [X+1]
 010D 0F0000            adc [X+0],0
 0110                   .dbline 136
 0110           ;               
 0110           ;               // If the e-stop line is low
 0110           ;               if (!(PRT1DR & ESTOP_MASK)){
 0110 5D04              mov A,REG[0x4]
 0112 62D000            mov REG[0xd0],>__r0
 0115 5300              mov [__r0],A
 0117 470004            tst [__r0],4
 011A B040              jnz L18
 011C                   .dbline 137
 011C           ;                       UART_CPutString("ESTOP");
 011C                   .dbline 137
 011C 10                push X
 011D 5050              mov A,>L20
 011F 08                push A
 0120 5050              mov A,<L20
 0122 5C                mov X,A
 0123 18                pop A
 0124 7C0000            xcall _UART_CPutString
 0127                   .dbline 138
 0127           ;                       UART_PutCRLF();
 0127 7C0000            xcall _UART_PutCRLF
 012A 20                pop X
 012B                   .dbline 140
 012B           ;                       
 012B           ;                       stop();
 012B 9355              xcall _stop
 012D                   .dbline 141
 012D           ;                       LCD_Position(0,0);
 012D 10                push X
 012E 5000              mov A,0
 0130 5700              mov X,0
 0132 7C0000            xcall _LCD_Position
 0135                   .dbline 142
 0135           ;                       LCD_PrCString("E-STOP");
 0135 5049              mov A,>L21
 0137 08                push A
 0138 5049              mov A,<L21
 013A 5C                mov X,A
 013B 18                pop A
 013C 7C0000            xcall _LCD_PrCString
 013F 20                pop X
 0140           L22:
 0140                   .dbline 144
 0140           ;                       
 0140           ;                       while (!(PRT1DR & ESTOP_MASK));
 0140           L23:
 0140                   .dbline 144
 0140 5D04              mov A,REG[0x4]
 0142 62D000            mov REG[0xd0],>__r0
 0145 5300              mov [__r0],A
 0147 470004            tst [__r0],4
 014A AFF5              jz L22
 014C                   .dbline 145
 014C           ;                       UART_CPutString("RESUME");
 014C 10                push X
 014D 5042              mov A,>L25
 014F 08                push A
 0150 5042              mov A,<L25
 0152 5C                mov X,A
 0153 18                pop A
 0154 7C0000            xcall _UART_CPutString
 0157                   .dbline 146
 0157           ;                       UART_PutCRLF();
 0157 7C0000            xcall _UART_PutCRLF
 015A 20                pop X
 015B                   .dbline 147
 015B           ;               }
 015B           L18:
 015B                   .dbline 149
 015B           ;               
 015B           ;               updateBrakeCtl();
 015B 933A              xcall _updateBrakeCtl
 015D                   .dbline 150
 015D           ;               updateTurnCtl();
 015D 93BD              xcall _updateTurnCtl
 015F                   .dbline 152
 015F           ; 
 015F           ;               if(UART_bCmdCheck()) 
 015F 10                push X
 0160 7C0000            xcall _UART_bCmdCheck
 0163 20                pop X
 0164 62D000            mov REG[0xd0],>__r0
 0167 3900              cmp A,0
 0169 A036              jz L26
 016B                   .dbline 155
 016B           ;               {
 016B           ;                       // Wait for command    
 016B           ;                       if(data = UART_szGetParam()) 
 016B                   .dbline 155
 016B 10                push X
 016C 7C0000            xcall _UART_szGetParam
 016F 62D000            mov REG[0xd0],>__r0
 0172 5300              mov [__r0],A
 0174 5A00              mov [__r1],X
 0176 20                pop X
 0177 5100              mov A,[__r1]
 0179 5403              mov [X+3],A
 017B 5100              mov A,[__r0]
 017D 5402              mov [X+2],A
 017F 3C0000            cmp [__r0],0
 0182 B006              jnz X4
 0184 3C0000            cmp [__r1],0
 0187 A013              jz L28
 0189           X4:
 0189                   .dbline 158
 0189           ;                       {
 0189           ;                               //UART_PutString(data);
 0189           ;                               command_lookup(*data);
 0189                   .dbline 158
 0189 62D000            mov REG[0xd0],>__r0
 018C 5203              mov A,[X+3]
 018E 5300              mov [__r1],A
 0190 5202              mov A,[X+2]
 0192 60D4              mov REG[0xd4],A
 0194 3E00              mvi A,[__r1]
 0196 08                push A
 0197 900E              xcall _command_lookup
 0199 38FF              add SP,-1
 019B                   .dbline 159
 019B           ;                       }   
 019B           L28:
 019B                   .dbline 160
 019B           ;                       UART_CmdReset();  // Reset command buffer     
 019B 10                push X
 019C 7C0000            xcall _UART_CmdReset
 019F 20                pop X
 01A0                   .dbline 161
 01A0           ;               }
 01A0           L26:
 01A0                   .dbline 162
 01A0           ;       }
 01A0           L13:
 01A0                   .dbline 121
 01A0 8F28              xjmp L12
 01A2           X2:
 01A2                   .dbline -2
 01A2           L9:
 01A2 38FC              add SP,-4
 01A4 20                pop X
 01A5                   .dbline 0 ; func end
 01A5 8FFF              jmp .
 01A7                   .dbsym l data 2 pc
 01A7                   .dbsym l heartbeat 0 i
 01A7                   .dbend
 01A7                   .dbfunc e command_lookup _command_lookup fI
 01A7           ;             TX -> X+5
 01A7           ;           data -> X+3
 01A7           ;          count -> X+1
 01A7           ;           baud -> X+0
 01A7           ;            cmd -> X-4
 01A7           _command_lookup::
 01A7                   .dbline -1
 01A7 10                push X
 01A8 4F                mov X,SP
 01A9 3809              add SP,9
 01AB                   .dbline 167
 01AB           ; }
 01AB           ; 
 01AB           ; //Parses the command buffer when new command received
 01AB           ; int command_lookup(BYTE cmd)
 01AB           ; {
 01AB                   .dbline 170
 01AB           ;       BYTE* data;
 01AB           ;       BYTE* TX;
 01AB           ;       BYTE baud = 0xAA;
 01AB 5600AA            mov [X+0],-86
 01AE                   .dbline 171
 01AE           ;       int count = 0;
 01AE 560200            mov [X+2],0
 01B1 560100            mov [X+1],0
 01B4                   .dbline 172
 01B4           ;       switch (cmd)
 01B4 52FC              mov A,[X-4]
 01B6 5408              mov [X+8],A
 01B8 560700            mov [X+7],0
 01BB 3D0700            cmp [X+7],0
 01BE B006              jnz X5
 01C0 3D0845            cmp [X+8],69
 01C3 A14C              jz L41
 01C5           X5:
 01C5 3D0700            cmp [X+7],0
 01C8 B006              jnz X6
 01CA 3D0848            cmp [X+8],72
 01CD A0F9              jz L37
 01CF           X6:
 01CF 3D0700            cmp [X+7],0
 01D2 B006              jnz X7
 01D4 3D0849            cmp [X+8],73
 01D7 A15A              jz L44
 01D9           X7:
 01D9 3D0700            cmp [X+7],0
 01DC B006              jnz X8
 01DE 3D084A            cmp [X+8],74
 01E1 A16E              jz L47
 01E3           X8:
 01E3 3D0700            cmp [X+7],0
 01E6 B006              jnz X9
 01E8 3D084C            cmp [X+8],76
 01EB A142              jz L43
 01ED           X9:
 01ED 3D0700            cmp [X+7],0
 01F0 B006              jnz X10
 01F2 3D0850            cmp [X+8],80
 01F5 A166              jz L48
 01F7           X10:
 01F7 3D0700            cmp [X+7],0
 01FA B006              jnz X11
 01FC 3D0851            cmp [X+8],81
 01FF A11F              jz L42
 0201           X11:
 0201 3D0700            cmp [X+7],0
 0204 B006              jnz X12
 0206 3D0852            cmp [X+8],82
 0209 A136              jz L45
 020B           X12:
 020B 3D0700            cmp [X+7],0
 020E B006              jnz X13
 0210 3D0853            cmp [X+8],83
 0213 A0E9              jz L40
 0215           X13:
 0215 3D0700            cmp [X+7],0
 0218 B006              jnz X14
 021A 3D0854            cmp [X+8],84
 021D A073              jz L34
 021F           X14:
 021F 5208              mov A,[X+8]
 0221 1145              sub A,69
 0223 5207              mov A,[X+7]
 0225 3180              xor A,-128
 0227 1980              sbb A,(0 ^ 0x80)
 0229 C15A              jc L31
 022B           X15:
 022B           L53:
 022B 3D0700            cmp [X+7],0
 022E B006              jnz X16
 0230 3D0865            cmp [X+8],101
 0233 A0DC              jz L41
 0235           X16:
 0235 3D0700            cmp [X+7],0
 0238 B006              jnz X17
 023A 3D0868            cmp [X+8],104
 023D A089              jz L37
 023F           X17:
 023F 3D0700            cmp [X+7],0
 0242 B006              jnz X18
 0244 3D0869            cmp [X+8],105
 0247 A0EA              jz L44
 0249           X18:
 0249 3D0700            cmp [X+7],0
 024C B006              jnz X19
 024E 3D086A            cmp [X+8],106
 0251 A0FE              jz L47
 0253           X19:
 0253 3D0700            cmp [X+7],0
 0256 B006              jnz X20
 0258 3D086C            cmp [X+8],108
 025B A0D2              jz L43
 025D           X20:
 025D 3D0700            cmp [X+7],0
 0260 B006              jnz X21
 0262 3D0870            cmp [X+8],112
 0265 A0F6              jz L48
 0267           X21:
 0267 3D0700            cmp [X+7],0
 026A B006              jnz X22
 026C 3D0871            cmp [X+8],113
 026F A0AF              jz L42
 0271           X22:
 0271 3D0700            cmp [X+7],0
 0274 B006              jnz X23
 0276 3D0872            cmp [X+8],114
 0279 A0C6              jz L45
 027B           X23:
 027B 3D0700            cmp [X+7],0
 027E B006              jnz X24
 0280 3D0873            cmp [X+8],115
 0283 A079              jz L40
 0285           X24:
 0285 3D0700            cmp [X+7],0
 0288 B006              jnz X25
 028A 3D0874            cmp [X+8],116
 028D A003              jz L34
 028F           X25:
 028F 80F4              xjmp L31
 0291           L34:
 0291                   .dbline 177
 0291           ;       {
 0291           ;               // Turn to a specific count
 0291           ;               case 'T':
 0291           ;               case 't':
 0291           ;                       if (data = UART_szGetParam())
 0291 10                push X
 0292 7C0000            xcall _UART_szGetParam
 0295 62D000            mov REG[0xd0],>__r0
 0298 5300              mov [__r0],A
 029A 5A00              mov [__r1],X
 029C 20                pop X
 029D 5100              mov A,[__r1]
 029F 5404              mov [X+4],A
 02A1 5100              mov A,[__r0]
 02A3 5403              mov [X+3],A
 02A5 3C0000            cmp [__r0],0
 02A8 B006              jnz X26
 02AA 3C0000            cmp [__r1],0
 02AD A0F3              jz L32
 02AF           X26:
 02AF                   .dbline 178
 02AF           ;                               turn(atoi(data));
 02AF 5203              mov A,[X+3]
 02B1 08                push A
 02B2 5204              mov A,[X+4]
 02B4 08                push A
 02B5 7C0000            xcall _atoi
 02B8 62D000            mov REG[0xd0],>__r0
 02BB 5100              mov A,[__r0]
 02BD 08                push A
 02BE 5100              mov A,[__r1]
 02C0 08                push A
 02C1 9343              xcall _turn
 02C3 38FC              add SP,-4
 02C5                   .dbline 183
 02C5           ;                       
 02C5           ;                       #ifdef VERBOSE
 02C5           ;                               else UART_CPutString("No value given!\r\n");
 02C5           ;                       #endif
 02C5           ;                       break;
 02C5 80DB              xjmp L32
 02C7           L37:
 02C7                   .dbline 188
 02C7           ;                                               
 02C7           ;               // Apply the brake to the specified value [100, 900]
 02C7           ;               case 'h':
 02C7           ;               case 'H':
 02C7           ;                       if (data = UART_szGetParam())
 02C7 10                push X
 02C8 7C0000            xcall _UART_szGetParam
 02CB 62D000            mov REG[0xd0],>__r0
 02CE 5300              mov [__r0],A
 02D0 5A00              mov [__r1],X
 02D2 20                pop X
 02D3 5100              mov A,[__r1]
 02D5 5404              mov [X+4],A
 02D7 5100              mov A,[__r0]
 02D9 5403              mov [X+3],A
 02DB 3C0000            cmp [__r0],0
 02DE B006              jnz X27
 02E0 3C0000            cmp [__r1],0
 02E3 A0BD              jz L32
 02E5           X27:
 02E5                   .dbline 189
 02E5           ;                               brake(atoi(data));
 02E5 5203              mov A,[X+3]
 02E7 08                push A
 02E8 5204              mov A,[X+4]
 02EA 08                push A
 02EB 7C0000            xcall _atoi
 02EE 62D000            mov REG[0xd0],>__r0
 02F1 5100              mov A,[__r0]
 02F3 08                push A
 02F4 5100              mov A,[__r1]
 02F6 08                push A
 02F7 9350              xcall _brake
 02F9 38FC              add SP,-4
 02FB                   .dbline 194
 02FB           ;                       
 02FB           ;                       #ifdef VERBOSE
 02FB           ;                               else UART_CPutString("No brake value given!!!\r\n");
 02FB           ;                       #endif
 02FB           ;                       break;
 02FB 80A5              xjmp L32
 02FD           L40:
 02FD                   .dbline 199
 02FD           ;                       
 02FD           ;               // Request the steer encoder count
 02FD           ;               case 'S':
 02FD           ;               case 's':
 02FD           ;                       UART_PutSHexInt(steerCount);
 02FD 10                push X
 02FE 62D000            mov REG[0xd0],>_steerCount
 0301 5100              mov A,[_steerCount]
 0303 08                push A
 0304 5101              mov A,[_steerCount+1]
 0306 20                pop X
 0307 7C0000            xcall _UART_PutSHexInt
 030A                   .dbline 200
 030A           ;                       UART_PutCRLF();
 030A 7C0000            xcall _UART_PutCRLF
 030D 20                pop X
 030E                   .dbline 201
 030E           ;                       break;
 030E 8092              xjmp L32
 0310           L41:
 0310                   .dbline 210
 0310           ;                       
 0310           ;               // Manual turning right
 0310           ;               case 'E':
 0310           ;               case 'e':
 0310           ;                       #ifdef VERBOSE
 0310           ;                               UART_CPutString("Turning Right\r\n");
 0310           ;                       #endif
 0310           ;                       
 0310           ;                       setControllerSpeed(STEER_CTL, STEER_SPEED, RIGHT);
 0310 5001              mov A,1
 0312 08                push A
 0313 5050              mov A,80
 0315 08                push A
 0316 5080              mov A,-128
 0318 08                push A
 0319 9098              xcall _setControllerSpeed
 031B 38FD              add SP,-3
 031D                   .dbline 211
 031D           ;                       break;
 031D 8083              xjmp L32
 031F           L42:
 031F                   .dbline 220
 031F           ;                       
 031F           ;               // Manual turning left
 031F           ;               case 'Q':
 031F           ;               case 'q':
 031F           ;                       #ifdef VERBOSE
 031F           ;                               UART_CPutString("Turning Left\r\n");
 031F           ;                       #endif
 031F           ;                       
 031F           ;                       setControllerSpeed(STEER_CTL, STEER_SPEED, LEFT);
 031F 5000              mov A,0
 0321 08                push A
 0322 5050              mov A,80
 0324 08                push A
 0325 5080              mov A,-128
 0327 08                push A
 0328 9089              xcall _setControllerSpeed
 032A 38FD              add SP,-3
 032C                   .dbline 221
 032C           ;                       break;
 032C 8074              xjmp L32
 032E           L43:
 032E                   .dbline 226
 032E           ;                       
 032E           ;               //manual stopping
 032E           ;               case 'L':
 032E           ;               case 'l':
 032E           ;                       stop();
 032E 9152              xcall _stop
 0330                   .dbline 227
 0330           ;                       break;
 0330 8070              xjmp L32
 0332           L44:
 0332                   .dbline 232
 0332           ;                       
 0332           ;               //sending the baud character
 0332           ;               case 'I':
 0332           ;               case 'i':
 0332           ;                       UART_PutChar('S');
 0332 10                push X
 0333 5053              mov A,83
 0335 7C0000            xcall _UART_PutChar
 0338                   .dbline 233
 0338           ;                       TX8_PutChar((CHAR)BAUD_BYTE);           
 0338 50AA              mov A,-86
 033A 7C0000            xcall _TX8_PutChar
 033D 20                pop X
 033E                   .dbline 234
 033E           ;                       break;
 033E 8062              xjmp L32
 0340           L45:
 0340                   .dbline 239
 0340           ;                       
 0340           ;               //reset the position of the wheels to '0'
 0340           ;               case 'R':
 0340           ;               case 'r':
 0340           ;                       calibrateSteering();
 0340 934A              xcall _calibrateSteering
 0342                   .dbline 240
 0342           ;                       UART_CPutString("Shaft Reset\r\n");
 0342 10                push X
 0343 5034              mov A,>L46
 0345 08                push A
 0346 5034              mov A,<L46
 0348 5C                mov X,A
 0349 18                pop A
 034A 7C0000            xcall _UART_CPutString
 034D 20                pop X
 034E                   .dbline 241
 034E           ;                       break;
 034E 8052              xjmp L32
 0350           L47:
 0350                   .dbline 247
 0350           ; 
 0350           ;                       
 0350           ;               // Fully release the brake
 0350           ;               case 'J':
 0350           ;               case 'j':
 0350           ;                       brake(100);
 0350 5000              mov A,0
 0352 08                push A
 0353 5064              mov A,100
 0355 08                push A
 0356 92F1              xcall _brake
 0358 38FE              add SP,-2
 035A                   .dbline 248
 035A           ;                       break;
 035A 8046              xjmp L32
 035C           L48:
 035C                   .dbline 253
 035C           ;                       
 035C           ;               // Request the value of the steer pot
 035C           ;               case 'P':
 035C           ;               case 'p':
 035C           ;                       UART_CPutString("Steer pot is at >");
 035C 10                push X
 035D 5022              mov A,>L49
 035F 08                push A
 0360 5022              mov A,<L49
 0362 5C                mov X,A
 0363 18                pop A
 0364 7C0000            xcall _UART_CPutString
 0367 20                pop X
 0368                   .dbline 254
 0368           ;                       UART_PutSHexInt(getSteerPotPosition());
 0368 925B              xcall _getSteerPotPosition
 036A 10                push X
 036B 62D000            mov REG[0xd0],>__r0
 036E 5100              mov A,[__r0]
 0370 08                push A
 0371 5100              mov A,[__r1]
 0373 20                pop X
 0374 7C0000            xcall _UART_PutSHexInt
 0377                   .dbline 255
 0377           ;                       UART_CPutString(" counts<\r\n");
 0377 5017              mov A,>L50
 0379 08                push A
 037A 5017              mov A,<L50
 037C 5C                mov X,A
 037D 18                pop A
 037E 7C0000            xcall _UART_CPutString
 0381 20                pop X
 0382                   .dbline 256
 0382           ;                       break;
 0382 801E              xjmp L32
 0384           L31:
 0384                   .dbline 260
 0384           ;                       
 0384           ;               //Invalid command
 0384           ;               default:
 0384           ;                       UART_CPutString("Invalid Command: >");
 0384 10                push X
 0385 5004              mov A,>L51
 0387 08                push A
 0388 5004              mov A,<L51
 038A 5C                mov X,A
 038B 18                pop A
 038C 7C0000            xcall _UART_CPutString
 038F 20                pop X
 0390                   .dbline 261
 0390           ;                       UART_PutChar(cmd);
 0390 10                push X
 0391 52FC              mov A,[X-4]
 0393 7C0000            xcall _UART_PutChar
 0396                   .dbline 262
 0396           ;                       UART_CPutString("<\n\r");
 0396 5000              mov A,>L52
 0398 08                push A
 0399 5000              mov A,<L52
 039B 5C                mov X,A
 039C 18                pop A
 039D 7C0000            xcall _UART_CPutString
 03A0 20                pop X
 03A1                   .dbline 263
 03A1           ;                       break;
 03A1           L32:
 03A1                   .dbline 265
 03A1           ;       }
 03A1           ;       UART_CmdReset();
 03A1 10                push X
 03A2 7C0000            xcall _UART_CmdReset
 03A5 20                pop X
 03A6                   .dbline 266
 03A6           ;       return 0;
 03A6 62D000            mov REG[0xd0],>__r0
 03A9 550000            mov [__r1],0
 03AC 550000            mov [__r0],0
 03AF                   .dbline -2
 03AF           L30:
 03AF 38F7              add SP,-9
 03B1 20                pop X
 03B2                   .dbline 0 ; func end
 03B2 7F                ret
 03B3                   .dbsym l TX 5 pc
 03B3                   .dbsym l data 3 pc
 03B3                   .dbsym l count 1 I
 03B3                   .dbsym l baud 0 c
 03B3                   .dbsym l cmd -4 c
 03B3                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           L55:
 0000 0000              .byte 0,0
                        .area text(rom, con, rel)
 03B3                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 03B3                   .dbfunc e setControllerSpeed _setControllerSpeed fV
 03B3                   .dbsym s lastValue L55 A[2:2]c
 03B3           ;             TX -> X+4
 03B3           ;            dir -> X-6
 03B3           ;          speed -> X-5
 03B3           ;           addr -> X-4
 03B3           _setControllerSpeed::
 03B3                   .dbline -1
 03B3 10                push X
 03B4 4F                mov X,SP
 03B5 380A              add SP,10
 03B7                   .dbline 269
 03B7           ; }
 03B7           ; 
 03B7           ; void setControllerSpeed(BYTE addr, BYTE speed, BYTE dir) {
 03B7                   .dbline 272
 03B7           ;       static BYTE lastValue[2];
 03B7           ;       
 03B7           ;       if (lastValue[addr == BRAKE_CTL ? 1 : 0] != dir << 7 | speed) {
 03B7 3DFC82            cmp [X-4],-126
 03BA B009              jnz L62
 03BC 560301            mov [X+3],1
 03BF 560200            mov [X+2],0
 03C2 8007              xjmp L63
 03C4           L62:
 03C4 560300            mov [X+3],0
 03C7 560200            mov [X+2],0
 03CA           L63:
 03CA 52FA              mov A,[X-6]
 03CC 62D000            mov REG[0xd0],>__r0
 03CF 64                asl A
 03D0 64                asl A
 03D1 64                asl A
 03D2 64                asl A
 03D3 64                asl A
 03D4 64                asl A
 03D5 64                asl A
 03D6 5300              mov [__r0],A
 03D8 5203              mov A,[X+3]
 03DA 0100              add A,<L55
 03DC 5300              mov [__r3],A
 03DE 5202              mov A,[X+2]
 03E0 0900              adc A,>L55
 03E2 60D4              mov REG[0xd4],A
 03E4 3E00              mvi A,[__r3]
 03E6 3A00              cmp A,[__r0]
 03E8 A009              jz L60
 03EA 560101            mov [X+1],1
 03ED 560000            mov [X+0],0
 03F0 8007              xjmp L61
 03F2           L60:
 03F2 560100            mov [X+1],0
 03F5 560000            mov [X+0],0
 03F8           L61:
 03F8 62D000            mov REG[0xd0],>__r0
 03FB 52FB              mov A,[X-5]
 03FD 5300              mov [__r1],A
 03FF 550000            mov [__r0],0
 0402 5201              mov A,[X+1]
 0404 2A00              or A,[__r1]
 0406 5300              mov [__r1],A
 0408 5200              mov A,[X+0]
 040A 2A00              or A,[__r0]
 040C 3900              cmp A,0
 040E B006              jnz X28
 0410 3C0000            cmp [__r1],0
 0413 A06A              jz L56
 0415           X28:
 0415                   .dbline 273
 0415           ;               BYTE TX[4];
 0415                   .dbline 274
 0415           ;               TX[0] = addr;
 0415 52FC              mov A,[X-4]
 0417 5404              mov [X+4],A
 0419                   .dbline 275
 0419           ;               TX[1] = dir;
 0419 52FA              mov A,[X-6]
 041B 5405              mov [X+5],A
 041D                   .dbline 276
 041D           ;               TX[2] = speed;
 041D 52FB              mov A,[X-5]
 041F 5406              mov [X+6],A
 0421                   .dbline 277
 0421           ;               TX[3] = (addr + dir + speed) & 0x7F;
 0421 62D000            mov REG[0xd0],>__r0
 0424 52FC              mov A,[X-4]
 0426 03FA              add A,[X-6]
 0428 5300              mov [__r0],A
 042A 52FB              mov A,[X-5]
 042C 0400              add [__r0],A
 042E 5100              mov A,[__r0]
 0430 217F              and A,127
 0432 5407              mov [X+7],A
 0434                   .dbline 278
 0434           ;               TX8_Write(TX,4);
 0434 10                push X
 0435 5004              mov A,4
 0437 08                push A
 0438 5A00              mov [__r1],X
 043A 060004            add [__r1],4
 043D 5007              mov A,7
 043F 08                push A
 0440 5100              mov A,[__r1]
 0442 08                push A
 0443 7C0000            xcall _TX8_Write
 0446 38FD              add SP,-3
 0448 20                pop X
 0449                   .dbline 280
 0449           ;               
 0449           ;               lastValue[addr == BRAKE_CTL ? 1 : 0] = dir << 7 | speed;
 0449 3DFC82            cmp [X-4],-126
 044C B009              jnz L68
 044E 560901            mov [X+9],1
 0451 560800            mov [X+8],0
 0454 8007              xjmp L69
 0456           L68:
 0456 560900            mov [X+9],0
 0459 560800            mov [X+8],0
 045C           L69:
 045C 52FA              mov A,[X-6]
 045E 62D000            mov REG[0xd0],>__r0
 0461 64                asl A
 0462 64                asl A
 0463 64                asl A
 0464 64                asl A
 0465 64                asl A
 0466 64                asl A
 0467 64                asl A
 0468 5300              mov [__r0],A
 046A 52FB              mov A,[X-5]
 046C 2C00              or [__r0],A
 046E 5209              mov A,[X+9]
 0470 0100              add A,<L55
 0472 5300              mov [__r3],A
 0474 5208              mov A,[X+8]
 0476 0900              adc A,>L55
 0478 60D5              mov REG[0xd5],A
 047A 5100              mov A,[__r0]
 047C 3F00              mvi [__r3],A
 047E                   .dbline 281
 047E           ;       }
 047E           L56:
 047E                   .dbline -2
 047E           L54:
 047E 38F6              add SP,-10
 0480 20                pop X
 0481                   .dbline 0 ; func end
 0481 7F                ret
 0482                   .dbsym l TX 4 A[4:4]c
 0482                   .dbsym l dir -6 c
 0482                   .dbsym l speed -5 c
 0482                   .dbsym l addr -4 c
 0482                   .dbend
 0482                   .dbfunc e stop _stop fV
 0482           _stop::
 0482                   .dbline -1
 0482                   .dbline 284
 0482           ; }
 0482           ; 
 0482           ; void stop(void) {
 0482                   .dbline 285
 0482           ;       setControllerSpeed(STEER_CTL, STOP, STOP);
 0482 5000              mov A,0
 0484 08                push A
 0485 08                push A
 0486 5080              mov A,-128
 0488 08                push A
 0489 9F28              xcall _setControllerSpeed
 048B                   .dbline 286
 048B           ;       setControllerSpeed(BRAKE_CTL, STOP, STOP);
 048B 5000              mov A,0
 048D 08                push A
 048E 08                push A
 048F 5082              mov A,-126
 0491 08                push A
 0492 9F1F              xcall _setControllerSpeed
 0494 38FA              add SP,-6
 0496                   .dbline -2
 0496           L70:
 0496                   .dbline 0 ; func end
 0496 7F                ret
 0497                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           L72:
 0000 0000              .byte 0,0
                        .area text(rom, con, rel)
 0497                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0497                   .dbfunc e updateBrakeCtl _updateBrakeCtl fV
 0497                   .dbsym s error L72 I
 0497           ;  brakePosition -> X+0
 0497           _updateBrakeCtl::
 0497                   .dbline -1
 0497 10                push X
 0498 4F                mov X,SP
 0499 3802              add SP,2
 049B                   .dbline 294
 049B           ;       
 049B           ;       #ifdef VERBOSE
 049B           ;               UART_CPutString("Stopping all motors!!");
 049B           ;               UART_PutCRLF();
 049B           ;       #endif
 049B           ; }
 049B           ; 
 049B           ; void updateBrakeCtl(void) {
 049B                   .dbline 295
 049B           ;       unsigned int brakePosition = getBrakePosition();
 049B 90E7              xcall _getBrakePosition
 049D 62D000            mov REG[0xd0],>__r0
 04A0 5100              mov A,[__r1]
 04A2 5401              mov [X+1],A
 04A4 5100              mov A,[__r0]
 04A6 5400              mov [X+0],A
 04A8                   .dbline 298
 04A8           ;       static int error;
 04A8           ;       
 04A8           ;       error = brakeSetpoint - brakePosition;
 04A8 62D000            mov REG[0xd0],>_brakeSetpoint
 04AB 5101              mov A,[_brakeSetpoint+1]
 04AD 1301              sub A,[X+1]
 04AF 62D000            mov REG[0xd0],>__r0
 04B2 5300              mov [__r1],A
 04B4 62D000            mov REG[0xd0],>_brakeSetpoint
 04B7 5100              mov A,[_brakeSetpoint]
 04B9 1B00              sbb A,[X+0]
 04BB 62D000            mov REG[0xd0],>__r0
 04BE 5300              mov [__r0],A
 04C0 5100              mov A,[__r1]
 04C2 08                push A
 04C3 5100              mov A,[__r0]
 04C5 62D000            mov REG[0xd0],>L72
 04C8 5300              mov [L72],A
 04CA 18                pop A
 04CB 5301              mov [L72+1],A
 04CD                   .dbline 300
 04CD           ;       
 04CD           ;       if (error < -20)
 04CD 5101              mov A,[L72+1]
 04CF 11EC              sub A,-20
 04D1 5100              mov A,[L72]
 04D3 3180              xor A,-128
 04D5 197F              sbb A,(-1 ^ 0x80)
 04D7 D010              jnc L73
 04D9           X29:
 04D9                   .dbline 301
 04D9           ;               setControllerSpeed(BRAKE_CTL, BRAKE_SPEED, APPLY);
 04D9 5001              mov A,1
 04DB 08                push A
 04DC 5078              mov A,120
 04DE 08                push A
 04DF 5082              mov A,-126
 04E1 08                push A
 04E2 9ECF              xcall _setControllerSpeed
 04E4 38FD              add SP,-3
 04E6 8031              xjmp L74
 04E8           L73:
 04E8                   .dbline 302
 04E8           ;       else if (error > 20)
 04E8 62D000            mov REG[0xd0],>L72
 04EB 5014              mov A,20
 04ED 1201              sub A,[L72+1]
 04EF 5100              mov A,[L72]
 04F1 3180              xor A,-128
 04F3 62D000            mov REG[0xd0],>__r0
 04F6 5300              mov [__rX],A
 04F8 5080              mov A,(0 ^ 0x80)
 04FA 1A00              sbb A,[__rX]
 04FC D010              jnc L75
 04FE           X30:
 04FE                   .dbline 303
 04FE           ;               setControllerSpeed(BRAKE_CTL, BRAKE_SPEED, RELEASE);
 04FE 5000              mov A,0
 0500 08                push A
 0501 5078              mov A,120
 0503 08                push A
 0504 5082              mov A,-126
 0506 08                push A
 0507 9EAA              xcall _setControllerSpeed
 0509 38FD              add SP,-3
 050B 800C              xjmp L76
 050D           L75:
 050D                   .dbline 305
 050D           ;       else
 050D           ;               setControllerSpeed(BRAKE_CTL, STOP, STOP);
 050D 5000              mov A,0
 050F 08                push A
 0510 08                push A
 0511 5082              mov A,-126
 0513 08                push A
 0514 9E9D              xcall _setControllerSpeed
 0516 38FD              add SP,-3
 0518           L76:
 0518           L74:
 0518                   .dbline -2
 0518           L71:
 0518 38FE              add SP,-2
 051A 20                pop X
 051B                   .dbline 0 ; func end
 051B 7F                ret
 051C                   .dbsym l brakePosition 0 i
 051C                   .dbend
 051C                   .dbfunc e updateTurnCtl _updateTurnCtl fV
 051C           ;          error -> X+0
 051C           _updateTurnCtl::
 051C                   .dbline -1
 051C 10                push X
 051D 4F                mov X,SP
 051E 3802              add SP,2
 0520                   .dbline 308
 0520           ; }
 0520           ; 
 0520           ; void updateTurnCtl(void) {
 0520                   .dbline 309
 0520           ;       int error = steerSetpoint - steerCount;
 0520 62D000            mov REG[0xd0],>_steerSetpoint
 0523 5101              mov A,[_steerSetpoint+1]
 0525 62D000            mov REG[0xd0],>_steerCount
 0528 1201              sub A,[_steerCount+1]
 052A 5401              mov [X+1],A
 052C 62D000            mov REG[0xd0],>_steerSetpoint
 052F 5100              mov A,[_steerSetpoint]
 0531 62D000            mov REG[0xd0],>_steerCount
 0534 1A00              sbb A,[_steerCount]
 0536 5400              mov [X+0],A
 0538                   .dbline 311
 0538           ;       
 0538           ;       if (error < -20)
 0538 5201              mov A,[X+1]
 053A 11EC              sub A,-20
 053C 5200              mov A,[X+0]
 053E 3180              xor A,-128
 0540 197F              sbb A,(-1 ^ 0x80)
 0542 D010              jnc L78
 0544           X31:
 0544                   .dbline 312
 0544           ;               setControllerSpeed(STEER_CTL, STEER_SPEED, RIGHT);
 0544 5001              mov A,1
 0546 08                push A
 0547 5050              mov A,80
 0549 08                push A
 054A 5080              mov A,-128
 054C 08                push A
 054D 9E64              xcall _setControllerSpeed
 054F 38FD              add SP,-3
 0551 802E              xjmp L79
 0553           L78:
 0553                   .dbline 313
 0553           ;       else if (error > 20)
 0553 5014              mov A,20
 0555 1301              sub A,[X+1]
 0557 5200              mov A,[X+0]
 0559 3180              xor A,-128
 055B 62D000            mov REG[0xd0],>__r0
 055E 5300              mov [__rX],A
 0560 5080              mov A,(0 ^ 0x80)
 0562 1A00              sbb A,[__rX]
 0564 D010              jnc L80
 0566           X32:
 0566                   .dbline 314
 0566           ;               setControllerSpeed(STEER_CTL, STEER_SPEED, LEFT);
 0566 5000              mov A,0
 0568 08                push A
 0569 5050              mov A,80
 056B 08                push A
 056C 5080              mov A,-128
 056E 08                push A
 056F 9E42              xcall _setControllerSpeed
 0571 38FD              add SP,-3
 0573 800C              xjmp L81
 0575           L80:
 0575                   .dbline 316
 0575           ;       else
 0575           ;               setControllerSpeed(STEER_CTL, STOP, STOP);
 0575 5000              mov A,0
 0577 08                push A
 0578 08                push A
 0579 5080              mov A,-128
 057B 08                push A
 057C 9E35              xcall _setControllerSpeed
 057E 38FD              add SP,-3
 0580           L81:
 0580           L79:
 0580                   .dbline -2
 0580           L77:
 0580 38FE              add SP,-2
 0582 20                pop X
 0583                   .dbline 0 ; func end
 0583 7F                ret
 0584                   .dbsym l error 0 I
 0584                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           L83:
 0000 0000              .byte 0,0
                        .area text(rom, con, rel)
 0584                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0584                   .dbfunc e getBrakePosition _getBrakePosition fi
 0584                   .dbsym s brakePot L83 i
 0584           _getBrakePosition::
 0584                   .dbline -1
 0584                   .dbline 320
 0584           ; }
 0584           ; 
 0584           ; unsigned int getBrakePosition(void)
 0584           ; {
 0584                   .dbline 323
 0584           ;       static unsigned int brakePot;
 0584           ;       
 0584           ;       if (!cacheValid) {
 0584 62D000            mov REG[0xd0],>_cacheValid
 0587 3C0000            cmp [_cacheValid],0
 058A B029              jnz L84
 058C                   .dbline 324
 058C           ;               DUALADC_GetSamples(2);
 058C                   .dbline 324
 058C 10                push X
 058D 5002              mov A,2
 058F 7C0000            xcall _DUALADC_GetSamples
 0592 20                pop X
 0593           L86:
 0593                   .dbline 327
 0593           ;               
 0593           ;               // Wait for data to be ready
 0593           ;               while(DUALADC_fIsDataAvailable() == 0);
 0593           L87:
 0593                   .dbline 327
 0593 10                push X
 0594 7C0000            xcall _DUALADC_fIsDataAvailable
 0597 20                pop X
 0598 62D000            mov REG[0xd0],>__r0
 059B 3900              cmp A,0
 059D AFF5              jz L86
 059F                   .dbline 330
 059F           ;                       
 059F           ;               // Get Data and clear flag
 059F           ;               brakePot = DUALADC_iGetData2ClearFlag();
 059F 10                push X
 05A0 7C0000            xcall _DUALADC_iGetData2ClearFlag
 05A3 62D000            mov REG[0xd0],>__r0
 05A6 5A00              mov [__r0],X
 05A8 20                pop X
 05A9 08                push A
 05AA 5100              mov A,[__r0]
 05AC 62D000            mov REG[0xd0],>L83
 05AF 5300              mov [L83],A
 05B1 18                pop A
 05B2 5301              mov [L83+1],A
 05B4                   .dbline 331
 05B4           ;       }
 05B4           L84:
 05B4                   .dbline 333
 05B4           ;       
 05B4           ;       return brakePot;
 05B4 62D000            mov REG[0xd0],>L83
 05B7 5101              mov A,[L83+1]
 05B9 08                push A
 05BA 5100              mov A,[L83]
 05BC 62D000            mov REG[0xd0],>__r0
 05BF 5300              mov [__r0],A
 05C1 18                pop A
 05C2 5300              mov [__r1],A
 05C4                   .dbline -2
 05C4           L82:
 05C4                   .dbline 0 ; func end
 05C4 7F                ret
 05C5                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           L90:
 0000 0000              .byte 0,0
                        .area text(rom, con, rel)
 05C5                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 05C5                   .dbfunc e getSteerPotPosition _getSteerPotPosition fi
 05C5                   .dbsym s steerPot L90 i
 05C5           _getSteerPotPosition::
 05C5                   .dbline -1
 05C5                   .dbline 337
 05C5           ; }
 05C5           ; 
 05C5           ; unsigned int getSteerPotPosition(void)
 05C5           ; {
 05C5                   .dbline 340
 05C5           ;       static unsigned int steerPot;
 05C5           ;       
 05C5           ;       if (!cacheValid) {
 05C5 62D000            mov REG[0xd0],>_cacheValid
 05C8 3C0000            cmp [_cacheValid],0
 05CB B029              jnz L91
 05CD                   .dbline 341
 05CD           ;               DUALADC_GetSamples(2);
 05CD                   .dbline 341
 05CD 10                push X
 05CE 5002              mov A,2
 05D0 7C0000            xcall _DUALADC_GetSamples
 05D3 20                pop X
 05D4           L93:
 05D4                   .dbline 344
 05D4           ;               
 05D4           ;               // Wait for data to be ready
 05D4           ;               while(DUALADC_fIsDataAvailable() == 0);
 05D4           L94:
 05D4                   .dbline 344
 05D4 10                push X
 05D5 7C0000            xcall _DUALADC_fIsDataAvailable
 05D8 20                pop X
 05D9 62D000            mov REG[0xd0],>__r0
 05DC 3900              cmp A,0
 05DE AFF5              jz L93
 05E0                   .dbline 347
 05E0           ;                       
 05E0           ;               // Get Data and clear flag
 05E0           ;               steerPot = DUALADC_iGetData1ClearFlag();
 05E0 10                push X
 05E1 7C0000            xcall _DUALADC_iGetData1ClearFlag
 05E4 62D000            mov REG[0xd0],>__r0
 05E7 5A00              mov [__r0],X
 05E9 20                pop X
 05EA 08                push A
 05EB 5100              mov A,[__r0]
 05ED 62D000            mov REG[0xd0],>L90
 05F0 5300              mov [L90],A
 05F2 18                pop A
 05F3 5301              mov [L90+1],A
 05F5                   .dbline 348
 05F5           ;       }
 05F5           L91:
 05F5                   .dbline 350
 05F5           ;       
 05F5           ;       return steerPot;
 05F5 62D000            mov REG[0xd0],>L90
 05F8 5101              mov A,[L90+1]
 05FA 08                push A
 05FB 5100              mov A,[L90]
 05FD 62D000            mov REG[0xd0],>__r0
 0600 5300              mov [__r0],A
 0602 18                pop A
 0603 5300              mov [__r1],A
 0605                   .dbline -2
 0605           L89:
 0605                   .dbline 0 ; func end
 0605 7F                ret
 0606                   .dbend
 0606                   .dbfunc e turn _turn fV
 0606           ;          count -> X-5
 0606           _turn::
 0606                   .dbline -1
 0606 10                push X
 0607 4F                mov X,SP
 0608                   .dbline 354
 0608           ; }
 0608           ; 
 0608           ; void turn(int count)
 0608           ; {
 0608                   .dbline 355
 0608           ;       count = max(ENCODER_LEFT_BOUND, count);
 0608 52FB              mov A,[X-5]
 060A 08                push A
 060B 52FC              mov A,[X-4]
 060D 08                push A
 060E 50F7              mov A,-9
 0610 08                push A
 0611 5004              mov A,4
 0613 08                push A
 0614 9A24              xcall _max
 0616 62D000            mov REG[0xd0],>__r0
 0619 5100              mov A,[__r1]
 061B 54FC              mov [X-4],A
 061D 5100              mov A,[__r0]
 061F 54FB              mov [X-5],A
 0621                   .dbline 356
 0621           ;       count = min(ENCODER_RIGHT_BOUND, count);
 0621 52FB              mov A,[X-5]
 0623 08                push A
 0624 52FC              mov A,[X-4]
 0626 08                push A
 0627 5008              mov A,8
 0629 08                push A
 062A 50FC              mov A,-4
 062C 08                push A
 062D 99D1              xcall _min
 062F 38F8              add SP,-8
 0631 62D000            mov REG[0xd0],>__r0
 0634 5100              mov A,[__r1]
 0636 54FC              mov [X-4],A
 0638 5100              mov A,[__r0]
 063A 54FB              mov [X-5],A
 063C                   .dbline 358
 063C           ;       
 063C           ;       steerSetpoint = count;
 063C 62D000            mov REG[0xd0],>_steerSetpoint
 063F 52FC              mov A,[X-4]
 0641 5301              mov [_steerSetpoint+1],A
 0643 52FB              mov A,[X-5]
 0645 5300              mov [_steerSetpoint],A
 0647                   .dbline -2
 0647           L96:
 0647 20                pop X
 0648                   .dbline 0 ; func end
 0648 7F                ret
 0649                   .dbsym l count -5 I
 0649                   .dbend
 0649                   .dbfunc e brake _brake fV
 0649           ;           pVal -> X-5
 0649           _brake::
 0649                   .dbline -1
 0649 10                push X
 064A 4F                mov X,SP
 064B                   .dbline 368
 064B           ;       
 064B           ;       #ifdef VERBOSE
 064B           ;               UART_CPutString("Steer setpoint: ");
 064B           ;               UART_PutSHexInt(count);
 064B           ;               UART_PutCRLF();
 064B           ;       #endif
 064B           ; }
 064B           ; 
 064B           ; void brake(int pVal)
 064B           ; {
 064B                   .dbline 369
 064B           ;       pVal = max(BRAKE_MIN_POS, pVal);
 064B 52FB              mov A,[X-5]
 064D 08                push A
 064E 52FC              mov A,[X-4]
 0650 08                push A
 0651 5000              mov A,0
 0653 08                push A
 0654 5064              mov A,100
 0656 08                push A
 0657 99E1              xcall _max
 0659 62D000            mov REG[0xd0],>__r0
 065C 5100              mov A,[__r1]
 065E 54FC              mov [X-4],A
 0660 5100              mov A,[__r0]
 0662 54FB              mov [X-5],A
 0664                   .dbline 370
 0664           ;       pVal = min(BRAKE_MAX_POS, pVal);
 0664 52FB              mov A,[X-5]
 0666 08                push A
 0667 52FC              mov A,[X-4]
 0669 08                push A
 066A 5003              mov A,3
 066C 08                push A
 066D 5084              mov A,-124
 066F 08                push A
 0670 998E              xcall _min
 0672 38F8              add SP,-8
 0674 62D000            mov REG[0xd0],>__r0
 0677 5100              mov A,[__r1]
 0679 54FC              mov [X-4],A
 067B 5100              mov A,[__r0]
 067D 54FB              mov [X-5],A
 067F                   .dbline 372
 067F           ;       
 067F           ;       brakeSetpoint = pVal;
 067F 62D000            mov REG[0xd0],>_brakeSetpoint
 0682 52FC              mov A,[X-4]
 0684 5301              mov [_brakeSetpoint+1],A
 0686 52FB              mov A,[X-5]
 0688 5300              mov [_brakeSetpoint],A
 068A                   .dbline -2
 068A           L97:
 068A 20                pop X
 068B                   .dbline 0 ; func end
 068B 7F                ret
 068C                   .dbsym l pVal -5 I
 068C                   .dbend
 068C                   .dbfunc e calibrateSteering _calibrateSteering fV
 068C           ;            dir -> X+2
 068C           ;  steerPotvalue -> X+0
 068C           _calibrateSteering::
 068C                   .dbline -1
 068C 10                push X
 068D 4F                mov X,SP
 068E 3803              add SP,3
 0690                   .dbline 382
 0690           ;       
 0690           ;       #ifdef VERBOSE
 0690           ;               UART_CPutString("Brake setpoint: ");
 0690           ;               UART_PutSHexInt(pVal);
 0690           ;               UART_PutCRLF();
 0690           ;       #endif 
 0690           ; }
 0690           ; 
 0690           ; void calibrateSteering(void)
 0690           ; {
 0690                   .dbline 383
 0690           ;       BYTE dir = 0;
 0690 560200            mov [X+2],0
 0693                   .dbline 385
 0693           ;       
 0693           ;       unsigned int steerPotvalue = getSteerPotPosition();
 0693 9F30              xcall _getSteerPotPosition
 0695 62D000            mov REG[0xd0],>__r0
 0698 5100              mov A,[__r1]
 069A 5401              mov [X+1],A
 069C 5100              mov A,[__r0]
 069E 5400              mov [X+0],A
 06A0                   .dbline 387
 06A0           ;       
 06A0           ;       if (steerPotvalue < STEER_POT_CENTER) dir = RIGHT;
 06A0 5201              mov A,[X+1]
 06A2 1104              sub A,4
 06A4 5200              mov A,[X+0]
 06A6 1902              sbb A,2
 06A8 D006              jnc L99
 06AA           X33:
 06AA                   .dbline 387
 06AA 560201            mov [X+2],1
 06AD 800E              xjmp L100
 06AF           L99:
 06AF                   .dbline 388
 06AF           ;       else if (steerPotvalue > STEER_POT_CENTER) dir = LEFT;
 06AF 5004              mov A,4
 06B1 1301              sub A,[X+1]
 06B3 5002              mov A,2
 06B5 1B00              sbb A,[X+0]
 06B7 D004              jnc L101
 06B9           X34:
 06B9                   .dbline 388
 06B9 560200            mov [X+2],0
 06BC           L101:
 06BC           L100:
 06BC                   .dbline 390
 06BC           ;       
 06BC           ;       setControllerSpeed(STEER_CTL, STEER_SPEED, dir);
 06BC 5202              mov A,[X+2]
 06BE 08                push A
 06BF 5050              mov A,80
 06C1 08                push A
 06C2 5080              mov A,-128
 06C4 08                push A
 06C5 9CEC              xcall _setControllerSpeed
 06C7 38FD              add SP,-3
 06C9 800E              xjmp L104
 06CB           L103:
 06CB                   .dbline 393
 06CB           ;       
 06CB           ;       while (abs(steerPotvalue - STEER_POT_CENTER) > 30)
 06CB           ;       {
 06CB                   .dbline 394
 06CB           ;               steerPotvalue = getSteerPotPosition();
 06CB 9EF8              xcall _getSteerPotPosition
 06CD 62D000            mov REG[0xd0],>__r0
 06D0 5100              mov A,[__r1]
 06D2 5401              mov [X+1],A
 06D4 5100              mov A,[__r0]
 06D6 5400              mov [X+0],A
 06D8                   .dbline 395
 06D8           ;       }
 06D8           L104:
 06D8                   .dbline 392
 06D8 62D000            mov REG[0xd0],>__r0
 06DB 5201              mov A,[X+1]
 06DD 1104              sub A,4
 06DF 5300              mov [__r1],A
 06E1 5200              mov A,[X+0]
 06E3 1902              sbb A,2
 06E5 08                push A
 06E6 5100              mov A,[__r1]
 06E8 08                push A
 06E9 7C0000            xcall _abs
 06EC 38FE              add SP,-2
 06EE 62D000            mov REG[0xd0],>__r0
 06F1 501E              mov A,30
 06F3 1200              sub A,[__r1]
 06F5 5100              mov A,[__r0]
 06F7 3180              xor A,-128
 06F9 5300              mov [__rX],A
 06FB 5080              mov A,(0 ^ 0x80)
 06FD 1A00              sbb A,[__rX]
 06FF CFCB              jc L103
 0701           X35:
 0701                   .dbline 397
 0701           ;       
 0701           ;       setControllerSpeed(STEER_CTL, STOP, STOP);
 0701 5000              mov A,0
 0703 08                push A
 0704 08                push A
 0705 5080              mov A,-128
 0707 08                push A
 0708 9CA9              xcall _setControllerSpeed
 070A 38FD              add SP,-3
 070C                   .dbline 398
 070C           ;       steerCount = 0;
 070C 62D000            mov REG[0xd0],>_steerCount
 070F 550100            mov [_steerCount+1],0
 0712 550000            mov [_steerCount],0
 0715                   .dbline -2
 0715           L98:
 0715 38FD              add SP,-3
 0717 20                pop X
 0718                   .dbline 0 ; func end
 0718 7F                ret
 0719                   .dbsym l dir 2 c
 0719                   .dbsym l steerPotvalue 0 i
 0719                   .dbend
 0719                   .dbfunc e PSoC_GPIO_ISR_C _PSoC_GPIO_ISR_C fV
 0719           _PSoC_GPIO_ISR_C::
 0719                   .dbline -1
 0719 71C0              or F,-64
 071B 08                push A
 071C 5DD0              mov A,REG[0xd0]
 071E 08                push A
 071F                   .dbline 406
 071F           ; }
 071F           ; 
 071F           ; /******** INTERRUPTS ********/
 071F           ; 
 071F           ; //A ___|-----|_____|-----|____
 071F           ; //B   ____|-----|_____|-----|____
 071F           ; void PSoC_GPIO_ISR_C(void)
 071F           ; {
 071F                   .dbline 407
 071F           ;       curPrt = (PRT1DR & (OpEncA_MASK | OpEncB_MASK));                // Setting prevPort to only bits 1[4] and 1[5]
 071F 5D04              mov A,REG[0x4]
 0721 2130              and A,48
 0723 62D000            mov REG[0xd0],>_curPrt
 0726 5300              mov [_curPrt],A
 0728                   .dbline 410
 0728           ;                                                                                                                               // of PRT1DR
 0728           ;               
 0728           ;       if ((prevPrt == 0x00) && (curPrt == 0x10))      // If prevPort is 0x00 and then after the interrupt curPrt is
 0728 62D000            mov REG[0xd0],>_prevPrt
 072B 3C0000            cmp [_prevPrt],0
 072E B013              jnz L107
 0730 62D000            mov REG[0xd0],>_curPrt
 0733 3C0010            cmp [_curPrt],16
 0736 B00B              jnz L107
 0738                   .dbline 415
 0738           ;                                                                                               // 0x10 then A is high and B is low which means you wanted to
 0738           ;                                                                                               // increment by turning clockwise and hitting a rising edge on A
 0738           ;       {
 0738           ;               // Increasing the count when clockwise turn interrupt occurred
 0738           ;               steerCount++;
 0738                   .dbline 415
 0738 62D000            mov REG[0xd0],>_steerCount
 073B 7601              inc [_steerCount+1]
 073D 0E0000            adc [_steerCount],0
 0740                   .dbline 416
 0740           ;       }
 0740 8019              xjmp L108
 0742           L107:
 0742                   .dbline 417
 0742           ;       else if ((prevPrt == 0x00) && (curPrt == 0x20)) // If prevPort is 0x00 and then after the interrupt curPrt is
 0742 62D000            mov REG[0xd0],>_prevPrt
 0745 3C0000            cmp [_prevPrt],0
 0748 B011              jnz L109
 074A 62D000            mov REG[0xd0],>_curPrt
 074D 3C0020            cmp [_curPrt],32
 0750 B009              jnz L109
 0752                   .dbline 423
 0752           ;                                                                                                       // 0x20 then B is high and A is low which means you wanted to
 0752           ;                                                                                                       // decrement by turning counterclockwise and hitting 
 0752           ;                                                                                                       // a rising edge on B
 0752           ;       {
 0752           ;               // Decreasing the count when the counterclockwise interrupt occurred
 0752           ;               steerCount--;
 0752                   .dbline 423
 0752 62D000            mov REG[0xd0],>_steerCount
 0755 7A01              dec [_steerCount+1]
 0757 1E0000            sbb [_steerCount],0
 075A                   .dbline 424
 075A           ;       }
 075A           L109:
 075A           L108:
 075A                   .dbline -2
 075A           L106:
 075A 18                pop A
 075B 60D0              mov REG[208],A
 075D 18                pop A
 075E                   .dbline 0 ; func end
 075E 7E                reti
 075F                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _steerSetpoint::
 0000 0000              .byte 0,0
 0002                   .dbsym e steerSetpoint _steerSetpoint I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _brakeSetpoint::
 0000 0000              .byte 0,0
 0002                   .dbsym e brakeSetpoint _brakeSetpoint I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _steerCount::
 0000 0000              .byte 0,0
 0002                   .dbsym e steerCount _steerCount I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _cacheValid::
 0000 00                .byte 0
 0001                   .dbsym e cacheValid _cacheValid c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _curPrt::
 0000 00                .byte 0
 0001                   .dbsym e curPrt _curPrt c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\zaander\Golfcart\PSOC_P~1\PSOC_S~1\PSOC_S~1\PSOC_S~1\main.c
 0000           _prevPrt::
 0000 00                .byte 0
 0001                   .dbsym e prevPrt _prevPrt c
                        .area lit(rom, con, rel, lit)
 0000           L52:
 0000 3C0A0D00          .byte 60,10,13,0
 0004           L51:
 0004 496E76616C696420436F6D6D616E643A  .byte 'I,'n,'v,'a,'l,'i,'d,32,'C,'o,'m,'m,'a,'n,'d,58
 0014 203E00            .byte 32,62,0
 0017           L50:
 0017 20636F756E74733C0D0A00    .byte 32,'c,'o,'u,'n,'t,'s,60,13,10,0
 0022           L49:
 0022 537465657220706F7420697320617420  .byte 'S,'t,'e,'e,'r,32,'p,'o,'t,32,'i,'s,32,'a,'t,32
 0032 3E00              .byte 62,0
 0034           L46:
 0034 53686166742052657365740D0A00      .byte 'S,'h,'a,'f,'t,32,'R,'e,'s,'e,'t,13,10,0
 0042           L25:
 0042 524553554D4500    .byte 'R,'E,'S,'U,'M,'E,0
 0049           L21:
 0049 452D53544F5000    .byte 'E,45,'S,'T,'O,'P,0
 0050           L20:
 0050 4553544F5000      .byte 'E,'S,'T,'O,'P,0
 0056           L17:
 0056 70696E6700        .byte 'p,'i,'n,'g,0
 005B           L11:
 005B 53746565722050726F6772616D205374  .byte 'S,'t,'e,'e,'r,32,'P,'r,'o,'g,'r,'a,'m,32,'S,'t
 006B 6172740D0A00      .byte 'a,'r,'t,13,10,0
 0071           L10:
 0071 5374656572696E672050536F4300      .byte 'S,'t,'e,'e,'r,'i,'n,'g,32,'P,'S,'o,'C,0
